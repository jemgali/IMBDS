{
  "version": 3,
  "sources": ["../../leaflet-geometryutil/src/leaflet.geometryutil.js"],
  "sourcesContent": ["// Packaging/modules magic dance.\n(function (factory) {\n    var L;\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['leaflet'], factory);\n    } else if (typeof module !== 'undefined') {\n        // Node/CommonJS\n        L = require('leaflet');\n        module.exports = factory(L);\n    } else {\n        // Browser globals\n        if (typeof window.L === 'undefined')\n            throw 'Leaflet must be loaded first';\n        factory(window.L);\n    }\n}(function (L) {\n\"use strict\";\n\nL.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n};\n\n/**\n * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n * @name L.GeometryUtil\n */\n\nL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\n    /**\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\n\n        @tutorial distance-length\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlngA geographical point A\n        @param {L.LatLng} latlngB geographical point B\n        @returns {Number} planar distance\n     */\n    distance: function (map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n\n    /**\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {Number} planar distance\n    */\n    distanceSegment: function (map, latlng, latlngA, latlngB) {\n        var p = map.latLngToLayerPoint(latlng),\n           p1 = map.latLngToLayerPoint(latlngA),\n           p2 = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n    },\n\n    /**\n        Shortcut function for converting distance to readable distance.\n        @param {Number} distance distance to be converted\n        @param {String} unit 'metric' or 'imperial'\n        @returns {String} in yard or miles\n    */\n    readableDistance: function (distance, unit) {\n        var isMetric = (unit !== 'imperial'),\n            distanceStr;\n        if (isMetric) {\n            // show metres when distance is < 1km, then show km\n            if (distance > 1000) {\n                distanceStr = (distance  / 1000).toFixed(2) + ' km';\n            }\n            else {\n                distanceStr = distance.toFixed(1) + ' m';\n            }\n        }\n        else {\n            distance *= 1.09361;\n            if (distance > 1760) {\n                distanceStr = (distance / 1760).toFixed(2) + ' miles';\n            }\n            else {\n                distanceStr = distance.toFixed(1) + ' yd';\n            }\n        }\n        return distanceStr;\n    },\n\n    /**\n        Returns true if the latlng belongs to segment A-B\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n        @returns {boolean}\n     */\n    belongsSegment: function(latlng, latlngA, latlngB, tolerance) {\n        tolerance = tolerance === undefined ? 0.2 : tolerance;\n        var hypotenuse = latlngA.distanceTo(latlngB),\n            delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n        return delta/hypotenuse < tolerance;\n    },\n\n    /**\n     * Returns total length of line\n     * @tutorial distance-length\n     *\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Number} Total length (pixels for Point, meters for LatLng)\n     */\n    length: function (coords) {\n        var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n        return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;\n    },\n\n    /**\n     * Returns a list of accumulated length along a line.\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n     */\n    accumulatedLengths: function (coords) {\n        if (typeof coords.getLatLngs == 'function') {\n            coords = coords.getLatLngs();\n        }\n        if (coords.length === 0)\n            return [];\n        var total = 0,\n            lengths = [0];\n        for (var i = 0, n = coords.length - 1; i< n; i++) {\n            total += coords[i].distanceTo(coords[i+1]);\n            lengths.push(total);\n        }\n        return lengths;\n    },\n\n    /**\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {L.LatLng} Closest geographical point\n    */\n    closestOnSegment: function (map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var p = map.project(latlng, maxzoom),\n           p1 = map.project(latlngA, maxzoom),\n           p2 = map.project(latlngB, maxzoom),\n           closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n        return map.unproject(closest, maxzoom);\n    },\n\n    /**\n    Returns the closest point of a {L.LatLng} on a {L.Circle}\n\n    @tutorial closest\n\n    @param {L.LatLng} latlng - The position to search\n    @param {L.Circle} circle - A Circle defined by a center and a radius\n    @returns {L.LatLng} Closest geographical point on the circle circumference\n    */\n    closestOnCircle: function (circle, latLng) {\n        const center = circle.getLatLng();\n        const circleRadius = circle.getRadius();\n        const radius = typeof circleRadius === 'number' ? circleRadius : circleRadius.radius;\n        const x = latLng.lng;\n        const y = latLng.lat;\n        const cx = center.lng;\n        const cy = center.lat;\n        // dx and dy is the vector from the circle's center to latLng\n        const dx = x - cx;\n        const dy = y - cy;\n\n        // distance between the point and the circle's center\n        const distance = Math.sqrt(dx * dx + dy * dy)\n\n        // Calculate the closest point on the circle by adding the normalized vector to the center\n        const tx = cx + (dx / distance) * radius;\n        const ty = cy + (dy / distance) * radius;\n\n        return new L.LatLng(ty, tx);\n    },\n    \n\n    /**\n        Returns the closest latlng on layer.\n\n        Accept nested arrays\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n        @param {L.LatLng} latlng - The position to search\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n    */\n    closest: function (map, layer, latlng, vertices) {\n\n        var latlngs,\n            mindist = Infinity,\n            result = null,\n            i, n, distance, subResult;\n\n        if (layer instanceof Array) {\n            // if layer is Array<Array<T>>\n            if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n                // if we have nested arrays, we calc the closest for each array\n                // recursive\n                for (i = 0; i < layer.length; i++) {\n                    subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n                    if (subResult && subResult.distance < mindist) {\n                        mindist = subResult.distance;\n                        result = subResult;\n                    }\n                }\n                return result;\n            } else if (layer[0] instanceof L.LatLng\n                        || typeof layer[0][0] === 'number'\n                        || typeof layer[0].lat === 'number') { // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n                layer = L.polyline(layer);\n            } else {\n                return result;\n            }\n        }\n\n        // if we don't have here a Polyline, that means layer is incorrect\n        // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n        if (! ( layer instanceof L.Polyline ) )\n            return result;\n\n        // deep copy of latlngs\n        latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n        // add the last segment for L.Polygon\n        if (layer instanceof L.Polygon) {\n            // add the last segment for each child that is a nested array\n            var addLastSegment = function(latlngs) {\n                if (L.Polyline._flat(latlngs)) {\n                    latlngs.push(latlngs[0]);\n                } else {\n                    for (var i = 0; i < latlngs.length; i++) {\n                        addLastSegment(latlngs[i]);\n                    }\n                }\n            };\n            addLastSegment(latlngs);\n        }\n\n        // we have a multi polygon / multi polyline / polygon with holes\n        // use recursive to explore and return the good result\n        if ( ! L.Polyline._flat(latlngs) ) {\n            for (i = 0; i < latlngs.length; i++) {\n                // if we are at the lower level, and if we have a L.Polygon, we add the last segment\n                subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            }\n            return result;\n\n        } else {\n\n            // Lookup vertices\n            if (vertices) {\n                for(i = 0, n = latlngs.length; i < n; i++) {\n                    var ll = latlngs[i];\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                    if (distance < mindist) {\n                        mindist = distance;\n                        result = ll;\n                        result.distance = distance;\n                    }\n                }\n                return result;\n            }\n\n            // Keep the closest point of all segments\n            for (i = 0, n = latlngs.length; i < n-1; i++) {\n                var latlngA = latlngs[i],\n                    latlngB = latlngs[i+1];\n                distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n                if (distance <= mindist) {\n                    mindist = distance;\n                    result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n                    result.distance = distance;\n                }\n            }\n            return result;\n        }\n\n    },\n\n    /**\n        Returns the closest layer to latlng among a list of layers.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n    */\n    closestLayer: function (map, layers, latlng) {\n        var mindist = Infinity,\n            result = null,\n            ll = null,\n            distance = Infinity;\n\n        for (var i = 0, n = layers.length; i < n; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            } else {\n                if (layer instanceof L.Circle){\n                    ll = this.closestOnCircle(layer, latlng);\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                } else\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                if (distance < mindist) {\n                    mindist = distance;\n                    result = {layer: layer, latlng: ll, distance: distance};\n                }\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the n closest layers to latlng among a list of input layers.\n\n        @param {L.Map} map - Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers - Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @param {?Number} [n=layers.length] - the expected number of output layers.\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n    */\n    nClosestLayers: function (map, layers, latlng, n) {\n        n = typeof n === 'number' ? n : layers.length;\n\n        if (n < 1 || layers.length < 1) {\n            return null;\n        }\n\n        var results = [];\n        var distance, ll;\n\n        for (var i = 0, m = layers.length; i < m; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                results.push(subResult);\n            } else {\n                if (layer instanceof L.Circle){\n                    ll = this.closestOnCircle(layer, latlng);\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                } else\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                results.push({layer: layer, latlng: ll, distance: distance});\n            }\n        }\n\n        results.sort(function(a, b) {\n            return a.distance - b.distance;\n        });\n\n        if (results.length > n) {\n            return results.slice(0, n);\n        } else  {\n            return results;\n        }\n    },\n\n    /**\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\n       @param {L.Map} map Leaflet map to be used for this method\n       @param {Array<ILayer>} layers - A list of layers.\n       @param {L.LatLng} latlng - The position to search\n       @param {?Number} [radius=Infinity] - Search radius in pixels\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n     */\n    layersWithin: function(map, layers, latlng, radius) {\n      radius = typeof radius == 'number' ? radius : Infinity;\n\n      var results = [];\n      var ll = null;\n      var distance = 0;\n\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n\n        if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n        }\n        else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance;  // Can return null if layer has no points.\n        }\n\n        if (ll && distance < radius) {\n            results.push({layer: layer, latlng: ll, distance: distance});\n        }\n      }\n\n      var sortedResults = results.sort(function(a, b) {\n          return a.distance - b.distance;\n      });\n\n      return sortedResults;\n    },\n\n    /**\n        Returns the closest position from specified {LatLng} among specified layers,\n        with a maximum tolerance in pixels, providing snapping behaviour.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<ILayer>} layers - A list of layers to snap on.\n        @param {L.LatLng} latlng - The position to snap\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n    */\n    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\n        tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n        withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n\n        var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n        if (!result || result.distance > tolerance)\n            return null;\n\n        // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n        if (withVertices && typeof result.layer.getLatLngs == 'function') {\n            var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n            if (closest.distance < tolerance) {\n                result.latlng = closest;\n                result.distance = L.GeometryUtil.distance(map, closest, latlng);\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the Point located on a segment at the specified ratio of the segment length.\n        @param {L.Point} pA coordinates of point A\n        @param {L.Point} pB coordinates of point B\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n        @returns {L.Point} the interpolated point.\n    */\n    interpolateOnPointSegment: function (pA, pB, ratio) {\n        return L.point(\n            (pA.x * (1 - ratio)) + (ratio * pB.x),\n            (pA.y * (1 - ratio)) + (ratio * pB.y)\n        );\n    },\n\n    /**\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n        (-1 if the interpolated point is the first vertex)\n    */\n    interpolateOnLine: function (map, latLngs, ratio) {\n        latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;\n        var n = latLngs.length;\n        if (n < 2) {\n            return null;\n        }\n\n        // ensure the ratio is between 0 and 1;\n        ratio = Math.max(Math.min(ratio, 1), 0);\n\n        if (ratio === 0) {\n            return {\n                latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n                predecessor: -1\n            };\n        }\n        if (ratio == 1) {\n            return {\n                latLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),\n                predecessor: latLngs.length - 2\n            };\n        }\n\n        // project the LatLngs as Points,\n        // and compute total planar length of the line at max precision\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var pts = [];\n        var lineLength = 0;\n        for(var i = 0; i < n; i++) {\n            pts[i] = map.project(latLngs[i], maxzoom);\n            if(i > 0)\n              lineLength += pts[i-1].distanceTo(pts[i]);\n        }\n\n        var ratioDist = lineLength * ratio;\n\n\t\t// follow the line segments [ab], adding lengths,\n        // until we find the segment where the points should lie on\n\t\tvar cumulativeDistanceToA = 0, cumulativeDistanceToB = 0;\n\t\tfor (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n\t\t\tvar pointA = pts[i], pointB = pts[i+1];\n\n\t\t\tcumulativeDistanceToA = cumulativeDistanceToB;\n\t\t\tcumulativeDistanceToB += pointA.distanceTo(pointB);\n\t\t}\n\t\t\n\t\tif (pointA == undefined && pointB == undefined) { // Happens when line has no length\n\t\t\tvar pointA = pts[0], pointB = pts[1], i = 1;\n\t\t}\n\n\t\t// compute the ratio relative to the segment [ab]\n\t\tvar segmentRatio = ((cumulativeDistanceToB - cumulativeDistanceToA) !== 0) ? ((ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA)) : 0;\n\t\tvar interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n\t\treturn {\n\t\t\tlatLng: map.unproject(interpolatedPoint, maxzoom),\n\t\t\tpredecessor: i-1\n\t\t};\n    },\n\n    /**\n        Returns a float between 0 and 1 representing the location of the\n        closest point on polyline to the given latlng, as a fraction of total line length.\n        (opposite of L.GeometryUtil.interpolateOnLine())\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\n        @param {L.LatLng} latlng The position to search\n        @returns {Number} Float between 0 and 1\n    */\n    locateOnLine: function (map, polyline, latlng) {\n        var latlngs = polyline.getLatLngs();\n        if (latlng.equals(latlngs[0]))\n            return 0.0;\n        if (latlng.equals(latlngs[latlngs.length-1]))\n            return 1.0;\n\n        var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n            lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n            total_length = lengths[lengths.length-1],\n            portion = 0,\n            found = false;\n        for (var i=0, n = latlngs.length-1; i < n; i++) {\n            var l1 = latlngs[i],\n                l2 = latlngs[i+1];\n            portion = lengths[i];\n            if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\n                portion += l1.distanceTo(point);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n        }\n        return portion / total_length;\n    },\n\n    /**\n        Returns a clone with reversed coordinates.\n        @param {L.PolyLine} polyline polyline to reverse\n        @returns {L.PolyLine} polyline reversed\n    */\n    reverse: function (polyline) {\n        return L.polyline(polyline.getLatLngs().slice(0).reverse());\n    },\n\n    /**\n        Returns a sub-part of the polyline, from start to end.\n        If start is superior to end, returns extraction from inverted line.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Array<L.LatLng>} new polyline\n     */\n    extract: function (map, polyline, start, end) {\n        if (start > end) {\n            return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);\n        }\n\n        // Bound start and end to [0-1]\n        start = Math.max(Math.min(start, 1), 0);\n        end = Math.max(Math.min(end, 1), 0);\n\n        var latlngs = polyline.getLatLngs(),\n            startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n            endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n        // Return single point if start == end\n        if (start == end) {\n            var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n            return [point.latLng];\n        }\n        // Array.slice() works indexes at 0\n        if (startpoint.predecessor == -1)\n            startpoint.predecessor = 0;\n        if (endpoint.predecessor == -1)\n            endpoint.predecessor = 0;\n        var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);\n        result.unshift(startpoint.latLng);\n        result.push(endpoint.latLng);\n        return result;\n    },\n\n    /**\n        Returns true if first polyline ends where other second starts.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isBefore: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[lla.length-1]).equals(llb[0]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isAfter: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[0]).equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends or start.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    startsAtExtremity: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs(),\n            start = lla[0];\n        return start.equals(llb[0]) || start.equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns horizontal angle in degres between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Number} horizontal angle\n     */\n    computeAngle: function(a, b) {\n        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\n    },\n\n    /**\n       Returns slope (Ax+B) between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Object} with ``a`` and ``b`` properties.\n     */\n    computeSlope: function(a, b) {\n        var s = (b.y - a.y) / (b.x - a.x),\n            o = a.y - (s * a.x);\n        return {'a': s, 'b': o};\n    },\n\n    /**\n       Returns LatLng of rotated point around specified LatLng center.\n        @param {L.LatLng} latlngPoint: point to rotate\n        @param {double} angleDeg: angle to rotate in degrees\n        @param {L.LatLng} latlngCenter: center of rotation\n        @returns {L.LatLng} rotated point\n     */\n    rotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var angleRad = angleDeg*Math.PI/180,\n            pPoint = map.project(latlngPoint, maxzoom),\n            pCenter = map.project(latlngCenter, maxzoom),\n            x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,\n            y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;\n        return map.unproject(new L.Point(x2,y2), maxzoom);\n    },\n\n    /**\n       Returns the bearing in degrees clockwise from north (0 degrees)\n       from the first L.LatLng to the second, at the first LatLng\n       @param {L.LatLng} latlng1: origin point of the bearing\n       @param {L.LatLng} latlng2: destination point of the bearing\n       @returns {float} degrees clockwise from north.\n    */\n    bearing: function(latlng1, latlng2) {\n        var rad = Math.PI / 180,\n            lat1 = latlng1.lat * rad,\n            lat2 = latlng2.lat * rad,\n            lon1 = latlng1.lng * rad,\n            lon2 = latlng2.lng * rad,\n            y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n            x = Math.cos(lat1) * Math.sin(lat2) -\n                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n        var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;\n        return bearing >= 180 ? bearing-360 : bearing;\n    },\n\n    /**\n       Returns the point that is a distance and heading away from\n       the given origin point.\n       @param {L.LatLng} latlng: origin point\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n       for a great reference and examples.\n    */\n    destination: function(latlng, heading, distance) {\n        heading = (heading + 360) % 360;\n        var rad = Math.PI / 180,\n            radInv = 180 / Math.PI,\n            R = L.CRS.Earth.R, // approximation of Earth's radius\n            lon1 = latlng.lng * rad,\n            lat1 = latlng.lat * rad,\n            rheading = heading * rad,\n            sinLat1 = Math.sin(lat1),\n            cosLat1 = Math.cos(lat1),\n            cosDistR = Math.cos(distance / R),\n            sinDistR = Math.sin(distance / R),\n            lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *\n                sinDistR * Math.cos(rheading)),\n            lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *\n                cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n        lon2 = lon2 * radInv;\n        lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n        return L.latLng([lat2 * radInv, lon2]);\n    },\n\n    /**\n       Returns the the angle of the given segment and the Equator in degrees,\n       clockwise from 0 degrees north.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @returns {Float} the angle in degrees.\n    */\n    angle: function(map, latlngA, latlngB) {\n      var pointA = map.latLngToContainerPoint(latlngA),\n          pointB = map.latLngToContainerPoint(latlngB),\n          angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n      angleDeg += angleDeg < 0 ? 360 : 0;\n      return angleDeg;\n    },\n\n    /**\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n    */\n    destinationOnSegment: function(map, latlngA, latlngB, distance) {\n      var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n          latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n      return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n    },\n});\n\nreturn L.GeometryUtil;\n\n}));\n"],
  "mappings": "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",
  "names": ["latlngs", "i"]
}
